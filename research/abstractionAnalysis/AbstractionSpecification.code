include analysis.pt

<define PARSE LIST(CODE.Abstraction, "\n")/>
<define TOKEN (("." "." ".") ("("")"))/>
<define EXP_UOP ("EqualOrMoreData")/>
<define KEYWORDS ("Positions")/>

<code NData pars=(state1 : CODE.AbstractionState, n : INT)>
@state1@^@n@
</code>

<code NMoreData pars=(state1 : CODE.AbstractionState, n : INT)>
@state1@^@n@+
</code>

<code ArbitraryData> ... </code>

<code Abstraction
pars=(name : ID, 
      data : CODE.AbstractionState, 
      varDecls : LIST(CODE.VarDecl,";"), 
      methods : LIST(CODE.AbstractionFunction, "\n")) 
symtab=""
parse=( 
      name ":"  eval(XFORM.enter_block("NEW")) data "where" varDecls
      "{" methods "}"";"
      eval(foreach v=CODE.VarDecl#(vars, type) \in varDecls do
        insert_typeInfo(type, vars);
      enddo;)
      eval(return(Abstraction[symtab=XFORM.exit_block(data)]#(name,data,varDecls,methods))))>
@name@ : @data@
{
  @methods@
};
</code>

<code AbstractionFunction pars=(name : ID, body : LIST(CODE.TransitionSpec, "\n"))>
@name@ : @body@
</code>

<code AbstractionState pars=(variables : LIST(ID|CODE.ArbitraryData|CODE.NData|CODE.NMoreData,""))>
{ @variables@ }
</code>

<code AbstractionStateImpl pars=(variables : LIST(CODE.ArbitraryData|ID,""))>
{ @variables@ }
</code>

<code TransitionSpec 
pars = (AbstractionStartState : CODE.AbstractionState, inputs : CODE.RestOfInput|"",
       AbstractionEndState : CODE.AbstractionState, outputs : CODE.RestOfOutput|"")> 
@AbstractionStartState@@inputs@ -> @AbstractionEndState@@outputs@;
</code>

<code Object pars=(val : ID | CODE.ArbitraryData)>
@val@
</code>

<code RestOfInput pars=(val : LIST1(CODE.Object,"*"))> 
*@val@
</code>

<code RestOfOutput pars=(val : LIST(CODE.Object,"*"))> 
*@val@
</code>

<code VarDecl pars=(vars : LIST(ID,","), type : "Positions"|"")> 
@vars@ : @type@
</code>
